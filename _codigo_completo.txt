<!-- index.html -->
```
<!DOCTYPE html>
<html lang="es-MX" xml:lang="es-MX">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Metrónomo">
  <meta name="image" content="https://lengua.la/metro/metro.jpg">
  <meta name="author" content="Santiago Chávez Novaro">
  <link rel="manifest" href="https://lengua.la/metro/manifest.json">
  <title>Metronomo</title>
  <meta name="theme-color" content="#222323" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Metrónomo">
  <meta name="apple-mobile-web-app-title" content="Metrónomo">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="og:title" content="Metrónomo">
  <meta name="og:description" content="Metrónomo irregular circular con sonidos reales, ligero y fácil de instalar en cualquier dispositivo desde el navegador.">
  <meta name="og:image" content="https://lengua.la/metro/metro.jpg">
  <meta name="og:url" content="https://lengua.la/metro/">
  <meta name="og:site_name" content="Sociedad Matemática Mexicana">
  <meta name="og:locale" content="es_MX">
  <meta name="og:type" content="website">
  <meta name="website:author" content="Santiago Chávez Novaro">
  <meta itemprop="name" content="Metrónomo">
  <meta itemprop="description" content="Metrónomo irregular circular con sonidos reales, ligero y fácil de instalar en cualquier dispositivo desde el navegador.">
  <meta itemprop="image" content="https://lengua.la/metro/metro.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Metrónomo">
  <meta name="twitter:description" content="Metrónomo irregular circular con sonidos reales, ligero y fácil de instalar en cualquier dispositivo desde el navegador.">
  <meta name="twitter:site" content="@grupolalengua">
  <meta name="twitter:creator" content="@sanxofon">
  <meta name="twitter:image:src" content="https://lengua.la/metro/metro.jpg">
  <meta name="format-detection" content="telephone=no">
  <link rel="icon" type="image/png" sizes="192x192" href="https://lengua.la/metro/icon-192x192.png">
  <link rel="apple-touch-icon" href="https://lengua.la/metro/icon-192x192.png">
  <link rel="shortcut icon" href="https://lengua.la/metro/favicon.png" type="image/png">
  <link rel="icon" href="https://lengua.la/metro/favicon.png" type="image/png">

  <link rel="stylesheet" href="metro.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
</head>
<body>
<div class="metronome">

  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span class="close">×</span>
      <h2>⏳ Historial</h2>
      <div><select id="historial" name="historial" size="8"></select></div>
      <div><a href="#" id="vaciarHistorial">Vaciar historial de patrones</a></div>
    </div>
  </div>

  <div class="recuadro reloj">

    <!-- DARK/LIGHT MODE SWITCH -->
    <div class="switch-div">
      <label class="switch" title="Modo Oscuro/Claro">
        <input type="checkbox" id="darkModeSwitch">
        <span class="slider round"></span>
      </label>
    </div>
  
    <!-- SETTINGS -->
    <div class="settings-icon" title="Configuración">
      ⏳ <!-- Gear icon entity -->
    </div>

    <!-- CÍRCULO -->
    <div class="clock">
      <div class="hand hour-hand"></div>
    </div>

    <!-- PATRÓN -->
    <div class="recuadro">
      <div id="patternLen" title="Longitud del patrón"></div>
      <div>
        <input type="text" id="beatPattern" placeholder="Ingrese un patrón rítmico (e.g., 1020)" value="">
      </div>
    </div>

  </div>

  <!-- PATRÓN -->
  <div class="recuadro">
    <div class="numberContainer">
      <div class="grid" id="numberGrid" title="Silenciar / Desilenciar"><div id="mute-icon" title="Silenciar / Desilenciar todos">&#128263;</div></div>
    </div>
  </div>
  
  <!-- HERRAMIENTAS -->
  <div class="recuadro">
    <div>
      <select title="Beats o Compases por minuto" id="BPM-CPM">
        <option value="0" title="Beats Por Minuto">BPM</option>
        <option value="1" title="Compases Por Minuto">CPM</option>
      </select>
      <input type="number" id="bpmInput" value="120" min="1" max="1000">
    </div>
    <div>
      <input type="range" id="bpmSlider" min="1" max="1000" value="120">
    </div>
    <div>
      <button id="startButton">&#9658;</button>
      
      <div class="recuadro beat-counter">0</div>
      <button id="stopButton">&#9724;</button>
    </div>
    <div>
      <input type="range" name="volumen" id="volumen" min="0" max="1" step="0.01" value="1">
      <br>
      <label for="volumen">Volumen</label>
    </div>
  </div>

  <h1>  
      Metrónomo
  </h1>

  <p>
    Selecciona la velocidad de los <i>beats</i> (BPM) o de <i>compás</i> (CPM) y escribe un patrón rítmico, puedes hacer <i>silencios</i> con <b class="mono">0</b> (cero) y usar <a href="javascript:playBeat(1);" class="mono">A</a>,
    <a href="javascript:playBeat(2);" class="mono">B</a>,
    <a href="javascript:playBeat(3);" class="mono">C</a>,
    <a href="javascript:playBeat(4);" class="mono">D</a>,
    <a href="javascript:playBeat(5);" class="mono">E</a>,
    <a href="javascript:playBeat(6);" class="mono">F</a>,
    <a href="javascript:playBeat(7);" class="mono">G</a>,
    <a href="javascript:playBeat(8);" class="mono">H</a>,
    <a href="javascript:playBeat(9);" class="mono">I</a> para los distintos <i>golpes</i>.
  </p>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
<script src="beats.js"></script>
<script src="metro.js"></script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(registration => {
        console.log('Service Worker registered:', registration);
        // Listen for updatefound event
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;

          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed') {
              // Show update prompt
              if (confirm("Nueva versión disponible. ¿Actualizar ahora?")) {
                window.location.reload(); // Refresh for update
              }
            }
          });
        });
      })
      .catch(error => console.error('Service Worker registration failed:', error));
  });
}
</script>
</body>
</html>
```

<!-- metro.css -->
```
@charset "UTF-8";

:root { 
  --clock-size: 200px;
  --max-size: 320px;
  font-size: 16px;
  --primary-color: #222323; /* Default primary color (dark) */
  --secondary-color: #FFFFFE; /* Default secondary color (light) */
  --accent-color: chocolate; 
}

/*  General Styles - Light Mode  */
body {
  background-color: #eee;
  color: var(--primary-color);
  transition: background-color 0.3s ease, color 0.3s ease; 
}

* {
  font-family: 'Roboto', Arial, sans-serif;
}

.mono {
  font-family: 'Roboto Mono', 'Courier New', Courier, monospace;
}

/* Contenedor principal del metrónomo */
.metronome {
  text-align: center;
  max-width: var(--max-size);
  margin: auto;
  position: relative;
}

h1 { /*  Encabezado  */
  margin-top: 0;
  margin-bottom: 0.5em;
}

p { /*  Párrafo explicativo  */
  text-align: left;
  font-size: 1.1em;
}

a { /*  Estilos para enlaces  */
  text-decoration: none;
  color: #400;
  font-weight: bold;
}

a:hover {
  text-decoration: underline;
}

/*  Recuadros generales  */
.recuadro {
  position: relative;
  display: inline-block;
  /* margin-bottom: 20px; */
  padding: 10px;
  /* border: 1px solid var(--primary-color); */
  border-radius: 10px;
  /* background: var(--secondary-color); */
}

/* Recuadro del reloj circular */
.recuadro.reloj {
  background-color: #eee;
  border: 2px solid #999;
  position: sticky;
  top: 2px;
  padding: 1px;
  z-index: 2;
  width: 100%;
}

/* Contador de beat */
.recuadro.beat-counter {
  font-size: 3em;
  line-height: 80%;
  width: 1.5em;
}

/*  Controles  */
button {
  padding: 5px 15px;
  margin: 0 10px;
  font-size: 2em;
  line-height: 100%;
  font-family: serif;
  cursor: pointer;
  width: 2em;
  height: 2em;
}

select, input {
  font-size: 1.7em;
  background-color: #fff;
  color: #333;
  border-color: #ccc;
  border-radius: 5px;
}

/* Sliders */
#bpmSlider, #volumen {
  width: var(--clock-size);
}

/*  Input del patrón de beats  */
#beatPattern {
  width: -moz-available;
  padding: 10px;
  font-size: 1.3em;
  font-family: 'Roboto Mono', 'Courier New', Courier, monospace;
}

#patternLen {
  position: absolute;
  min-width: 20px;
  top: 0;
  right: 0;
  color: var(--accent-color);
  background-color: #fff;
  border-radius: 5px;
}

/*  Reloj circular  */
.clock {
  margin: auto;
  width: var(--clock-size);
  height: var(--clock-size);
  border-radius: 50%;
  border: 2px solid #000;
  background-color: #FFF;
  position: relative;
}

/* Marcas de hora */
.hour-mark {
  position: absolute;
  width: 3px;
  height: calc((var(--clock-size) / 2) + 1px);
  transform-origin: 50% 100%; /*  Rotar desde la parte inferior  */
  margin-top: -1px;
  margin-left: calc((var(--clock-size) / 2) - 1px);
  background-color: rgba(0, 0, 0, 0.2); /* Default mark color */
}

/*  Colores de las marcas para cada tipo de beat  */
.hour-mark.beat1,.square.beat1 {
  background-color: rgba(255, 0, 0, 0.7)!important;
}

.hour-mark.beat2,.square.beat2 {
  background-color: rgba(0, 0, 255, 0.7)!important;
}

.hour-mark.beat3,.square.beat3 {
  background-color: rgba(0, 201, 0, 0.7)!important;
}

.hour-mark.beat4,.square.beat4 {
  background-color: rgba(0, 255, 255, 0.7)!important;
}

.hour-mark.beat5,.square.beat5 {
  background-color: rgba(255, 255, 0, 0.7)!important;
}

.hour-mark.beat6,.square.beat6 {
  background-color: rgba(149, 0, 194, 0.7)!important;
}

.hour-mark.beat7,.square.beat7 {
  background-color: rgba(255, 102, 0, 0.7)!important;
}

.hour-mark.beat8,.square.beat8 {
  background-color: rgba(253, 110, 182, 0.7)!important;
}

.hour-mark.beat9,.square.beat9 {
  background-color: rgba(179, 255, 0, 0.7)!important;
}
.hour-mark.off {
  background-color: rgba(0, 0, 0, 0.2)!important;
}

/* Manecilla del reloj */
.hand {
  width: 5px;
  height: calc(var(--clock-size) / 2);
  background-color: #000;
  position: absolute;
  top: 50%;
  left: 50%;
  transform-origin: 50% 100%; /*  Rotar desde la parte inferior  */
}

.hour-hand {
  height: calc(var(--clock-size) / 2);
  margin: 0;
  margin-left: -2px;
  margin-top: -50%;
}

/*  Cuadros de selección de números para silenciar  */
.numberContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  font-size: 1.4em;
}

.grid {
  display: grid;
  grid-template-columns: auto repeat(9, auto);
  gap: 0px;
}

.square {
  width: 22px;
  height: 22px;
  border: 2px solid #999; 
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 15px;
  cursor: pointer;
  margin: 2px;
}

.square:hover {
  border: 2px solid var(--primary-color);
}

.selected { /*  Cuadros seleccionados (silenciados)  */
  background-color: lightblue; 
  text-decoration: line-through;
  filter: grayscale(100%);
}

#mute-icon {
  filter: grayscale(100%) sepia(100%);
  font-size: 26px;
  margin-top: -4px;
  cursor: pointer;
}
#mute-icon:hover {
  filter: grayscale(100%);
}

/* Icono de configuración */
.settings-icon {
  position: absolute;
  top: 5px;
  right: 5px;
  font-size: 20px;
  cursor: pointer;
  color: var(--accent-color);
  filter: grayscale(100%) sepia(100%);
}

.settings-icon:hover {
  filter: grayscale(100%);
}

#historial {
  font-size: 1.2em;
  width: 300px;
}

/*  Modal de configuración  */
.modal {
  display: none; /*  Oculto por defecto  */
  position: fixed; 
  z-index: 99; 
  left: 0;
  top: 0;
  width: 100%; 
  height: 100%; 
  overflow: auto; 
}

.modal-content {
  background-color: var(--secondary-color);
  margin: 10% auto; /*  Centrar horizontal y verticalmente  */
  padding: 10px 20px 20px 20px;
  border: 1px solid var(--primary-color);
  width: 320px; 
  border-radius: 5px;
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
}

/* Botón de cierre del modal */
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close:hover,
.close:focus {
  color: var(--primary-color);
  text-decoration: none;
  cursor: pointer;
}

/*  Estilos para el grid de configuración  */
.settings-grid {
  display: grid;
  grid-template-columns: 1fr; /*  Una sola columna  */
  gap: 10px;
}


/*  Dark Mode Styles  */
body.dark-mode {
  --primary-color: #FFFFFE;
  --secondary-color: #222323;
  background-color: #111;
  color: var(--primary-color);
}

body.dark-mode .recuadro.reloj {
  background-color: #111;
}

body.dark-mode a {
  color: rgb(255, 235, 125);
}

body.dark-mode select, body.dark-mode input {
  background-color: #000;
  color: #fff;
  border-color: #666;
  border-radius: 5px;
}

body.dark-mode .clock {
  border: 2px solid #fff;
  background-color: #000;
}

body.dark-mode .hour-mark {
  background-color: rgba(255, 255, 255, 0.2); /* Default mark color */
}

body.dark-mode .hand {
  background-color: #fff;
}

body.dark-mode #patternLen {
  background-color: #000;
}

/*  DARK/LIGHT MODE SWITCH STYLE  */
/* Switch Dark Mode container */
.switch-div {
  position: absolute;
  top: 0;
  left: 0;
}
/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
  filter: grayscale(100%) sepia(100%);
}
.switch:hover {
  filter: grayscale(100%);
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
  transform: scale(0.6);
  border: 3px solid #999;
}

.slider:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 1px;
  background-color: #999;
  border: 3px solid #666;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}
```

<!-- metro.js -->
```
// metro.js
// Autor: Santiago Chávez Novaro
// Código Libre: Haz lo que quieras

// Elementos del DOM
// Botón Play
const startButton = document.getElementById('startButton');
// Botón Stop
const stopButton = document.getElementById('stopButton');
// Cuadro de texto del Patrón
const beatPatternInput = document.getElementById('beatPattern');
// Select entet Beats o Compases por minuto
const bpmcpm = document.getElementById('BPM-CPM');
// Input numérico de los BPM o CPM
const bpmInput = document.getElementById('bpmInput');
// Slider de Velocidad (Cambia los BPM o CPM)
const bpmSlider = document.getElementById('bpmSlider');
// Muestra el pulso actual
const beatCounter = document.querySelector('.beat-counter');
// El "reloj" circular
const clock = document.querySelector('.clock');
// "Manecilla" del círculo
const hourHand = document.querySelector('.hour-hand');
// Slider de volumen
const volumeSlider = document.getElementById('volumen');
// Grid del Mute de Golpes
const grid = document.getElementById('numberGrid');
// Div del ícono de Mutear Todos
const muteIcon = document.getElementById('mute-icon');
//  Elemento para mostrar la longitud del patrón
const patternLenDiv = document.getElementById('patternLen'); 
// Botón para vaciar el historial de patrones
const vaciarHistorial = document.getElementById('vaciarHistorial'); 

//  DARK/LIGHT MODE SWITCH
const darkModeSwitch = document.getElementById('darkModeSwitch');
const body = document.body;

// Valores por defecto de la UI
let beatPattern = localStorage.getItem('beatPattern') || 'ABA0'; // Default Patrón de golpes
let bpm = parseInt(localStorage.getItem('bpm')) || 120; // Default BPM/CPM
let isCPM = parseInt(localStorage.getItem('isCPM')) || 0; // Estamos en Compases Por Minuto? Default: 0
let volumen = parseFloat(localStorage.getItem('volumen')) || 1; // Volumen. Default 1=Max.
let selectedNumbers = JSON.parse(localStorage.getItem('selectedNumbers')) || []; // Números silenciados. Default: ninguno.
let darkMode = parseInt(localStorage.getItem('darkMode')) || 0; // Modo oscuro DARK MODE

// Variables globales
let beatsPerMeasure = beatPattern.length; // Beats por compás (calculado inicialmente del patrón por defecto)
let millisecondsPerBeat = 60000/bpm; // Milisegundos por beat (calculado inicialmente del BPM por defecto)
let isplaying = false; // Estado del metrónomo (iniciado o detenido)
let currentBeat = 0; // Índice del beat actual dentro del patrón
let intervalId; // ID del intervalo para controlarlo

// Actualiza la UI con los valores por defecto
bpmInput.value = bpm;
bpmSlider.value = bpm;
beatPatternInput.value = beatPattern;
bpmcpm.value = isCPM;
volumeSlider.value = volumen;

//  DARK/LIGHT MODE SWITCH
if (darkMode>0) {
  body.classList.add('dark-mode');
  darkModeSwitch.checked = true; 
}

// Traducciones entre LETRAS (cadena) y números (lista)
const traduccionN2T = {
  0:'0',
  1:'A',
  2:'B',
  3:'C',
  4:'D',
  5:'E',
  6:'F',
  7:'G',
  8:'H',
  9:'I',
};
const traduccionT2N = {
  '0':0,
  'A':1,
  'B':2,
  'C':3,
  'D':4,
  'E':5,
  'F':6,
  'G':7,
  'H':8,
  'I':9,
};
function transN2T(n) { // Recibe una lista de números
  console.log("N:",n);
  let t = [];
  for (let i = 0; i < n.length; i++) {
    t.push(traduccionN2T[n[i]]);
  }
  console.log("T:",t);
  return t.join(''); // Regresa una cadena de mayúsculas
}
function transT2N(s) { // Recibe una cadena de mayúsculas
  let n = [];
  const t = s.toUpperCase().replace(/[^A-I0]/g, '').split('');
  for (let i = 0; i < t.length; i++) {
    n.push(traduccionT2N[t[i]]);
  }
  return n; // regresa una lista de números
}
let listPattern = transT2N(beatPattern); // Default lista de golpes en números


// Funciones

// Guarda la configuración actual en localStorage
function saveSettings() {
  localStorage.setItem('beatPattern', beatPattern);
  localStorage.setItem('bpm', bpm);
  localStorage.setItem('isCPM', isCPM);
  localStorage.setItem('volumen',volumen);
  localStorage.setItem('selectedNumbers', JSON.stringify(selectedNumbers));
  localStorage.setItem('darkMode', darkMode);
}

// Crea las marcas de hora en el reloj circular
function createHourMarks(beatsPerMeasure) {
  // Borra las marcas existentes
  const elementsToDelete = document.querySelectorAll('.hour-mark');
  elementsToDelete.forEach(element => element.remove());

  // Crea nuevas marcas según el número de beats por compás
  for (let i = 0; i < beatsPerMeasure; i++) {
    const hourMark = document.createElement('div');
    hourMark.classList.add('hour-mark');
    // Asigna color según el tipo de beat (del patrón)
    if(listPattern[i]>0 && !selectedNumbers.includes(listPattern[i])) {
      hourMark.classList.add('beat'+listPattern[i]);
    }

    // Calcula el ángulo y rota la marca
    const angle = (i / beatsPerMeasure) * 360;
    hourMark.style.transform = `rotate(${angle}deg)`;
    clock.appendChild(hourMark);
  }
}

// Actualiza la posición de la manecilla del reloj y el contador de beat
function updateClock(beatsPerMeasure) {
  const hourAngle = (currentBeat / beatsPerMeasure) * 360; // Ángulo basado en el beat actual
  beatCounter.innerText = currentBeat+1; // Actualiza el contador de beat en la UI
  hourHand.style.transform = `rotate(${hourAngle}deg)`; // Rota la manecilla
}

// Carga los sonidos usando Howler.js
let sound = [];
for(var i = 0 ; i<base64Beat.length;i++){
  sound.push(new Howl({
    src: [base64Beat[i]]
    //src: ['https://s3-us-west-2.amazonaws.com/s.cdpn.io/3/success.mp3']
  }));
}

// Reproduce un sonido según el beat (si no está silenciado)
function playBeat(beat) {
  if(beat>0 && !selectedNumbers.includes(beat)) {
    sound[beat-1].play();
  }
}

// Inicia el metrónomo
function startMetronome() {
  isplaying = true; // Actualiza el estado del metrónomo
  saveSettings(); // Guarda la configuración actual
  beatPattern = beatPatternInput.value.toUpperCase().replace(/[^A-I0]/g, ''); // Limpia el patrón de entrada
  listPattern = transT2N(beatPattern);
  updatePatternLen();
  updateHistoryPattern(beatPattern); // Actualiza el historial de patrones
  updateHistorySelect(); // Actualiza el select del historial
  beatsPerMeasure = beatPattern.length; // Calcula beats por compás
  millisecondsPerBeat = (60000 / bpm); // Calcula ms por beat

  // Ajusta ms por beat si estamos en CPM
  if(isCPM>0) {
    millisecondsPerBeat = millisecondsPerBeat / beatsPerMeasure;
  }
  
  createHourMarks(beatsPerMeasure); // Crea las marcas de hora en el reloj


  // Inicia el intervalo para la reproducción de los beats
  intervalId = setInterval(() => {
    playBeat(listPattern[currentBeat]); // Reproduce el sonido del beat actual
    
    updateClock(beatsPerMeasure); // Actualiza el reloj
    
    currentBeat = (currentBeat + 1) % beatsPerMeasure; // Avanza al siguiente beat
  }, millisecondsPerBeat);

  // Actualiza el estado de los botones
  startButton.disabled = true;
  stopButton.disabled = false;
}

// Detiene el metrónomo
function stopMetronome() {
  clearInterval(intervalId); // Detiene el intervalo
  isplaying = false; // Actualiza el estado del metrónomo
  startButton.disabled = false; // Actualiza el estado de los botones
  stopButton.disabled = true;
  currentBeat = 0; // Reinicia el índice del beat actual
}

// Reinicia el metrónomo si hay un intervalo activo
function startIfIntervalId() {
  if (intervalId) {
    clearInterval(intervalId); // Detiene el intervalo actual
    if(isplaying) {
      startMetronome(); // Reinicia el metrónomo si estaba en reproducción
    }
  }  
}

// Event Listeners

// Actualiza el BPM cuando se cambia el input de texto
bpmInput.addEventListener('input', () => {
  bpm = parseInt(bpmInput.value);
  bpmSlider.value = bpm;
  startIfIntervalId(); // Reinicia el metrónomo
});

// Actualiza el BPM cuando se cambia el slider
bpmSlider.addEventListener('input', () => {
  bpm = parseInt(bpmSlider.value);
  bpmInput.value = bpm;
  startIfIntervalId(); // Reinicia el metrónomo
});

// Actualiza el modo BPM/CPM cuando se cambia el select
bpmcpm.addEventListener('input', () => {
  isCPM = parseInt(bpmcpm.value);
  bpmcpm.value = isCPM;
  startIfIntervalId(); // Reinicia el metrónomo
});

// Actualiza el volumen general cuando se cambia el slider
volumeSlider.addEventListener('input', () => {
  volumen = parseFloat(volumeSlider.value);
  sound.forEach(s => s.volume(volumen)); // Actualiza el volumen de todos los sonidos
  saveSettings(); // Guarda la configuración
});

// Inicia el metrónomo al hacer clic en el botón de inicio
startButton.addEventListener('click', startMetronome);

// Detiene el metrónomo al hacer clic en el botón de detener
stopButton.addEventListener('click', stopMetronome);


// Crea los Cuadros de Números de 1-9 (para silenciar)
for (let i = 1; i <= 9; i++) {
  const square = document.createElement('div');
  square.classList.add('square');
  square.classList.add('beat'+i);
  square.textContent = traduccionN2T[i];
  square.addEventListener('click', toggleSelect); // Agrega el listener para cambiar el estado de silenciado
  grid.appendChild(square);
  if (selectedNumbers.includes(i)) {
    square.classList.add('selected'); // Marca como silenciado si está en el array
  }
}

// Función para silenciar/desilenciar un número
function toggleSelect(event) {
  const square = event.target;
  const number = traduccionT2N[square.textContent];

  // Actualiza el estado del número y el array de números silenciados
  if (square.classList.contains('selected')) {
    square.classList.remove('selected');
    selectedNumbers = selectedNumbers.filter(n => n !== number);
  } else {
    square.classList.add('selected');
    selectedNumbers.push(number);
  }
  createHourMarks(beatsPerMeasure); // Crea las marcas de hora en el reloj
  saveSettings(); // Guarda la configuración
}

// Función para seleccionar/deseleccionar todos los números
function toggleSelectAll() {
  const squares = document.querySelectorAll('.square'); 
  const firstSquare = squares[0]; // Obtiene el primer cuadrado

  // Comprueba si el primer cuadrado está seleccionado
  if (firstSquare.classList.contains('selected')) {
    // Deselecciona todos
    squares.forEach(square => {
      square.classList.remove('selected');
      const number = traduccionT2N[square.textContent];
      selectedNumbers = selectedNumbers.filter(n => n !== number);
    });
  } else {
    // Selecciona todos
    squares.forEach(square => {
      square.classList.add('selected');
      const number = traduccionT2N[square.textContent];
      if (!selectedNumbers.includes(number)) { //  Evita duplicados
        selectedNumbers.push(number);
      }
    });
  }
  createHourMarks(beatsPerMeasure); // Crea las marcas de hora en el reloj
  saveSettings(); // Guarda la configuración
}

// Actualiza el historial de patrones en localStorage
function updateHistoryPattern(pattern) {
  // Obtiene el historial actual (o crea uno nuevo si no existe)
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern); 
  } else {
    historyPattern = []; 
  }

  // Elimina duplicados y agrega el nuevo patrón al inicio
  const existingIndex = historyPattern.indexOf(pattern);
  if (existingIndex !== -1) {
    historyPattern.splice(existingIndex, 1); 
  }
  historyPattern.unshift(pattern); 

  // Guarda el historial actualizado
  localStorage.setItem('historyPattern', JSON.stringify(historyPattern));
}

// Obtiene el siguiente patrón del historial
function getHistoryNext() {
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern);
    let currentIndex = parseInt(localStorage.getItem('historyIndex')) || 0; 

    // Avanza el índice, volviendo a 0 al final del historial
    currentIndex = (currentIndex + 1) % historyPattern.length;
    localStorage.setItem('historyIndex', currentIndex);

    return historyPattern[currentIndex]; 
  } 
  return null; 
}

// Obtiene el patrón anterior del historial
function getHistoryBack() {
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern);
    let currentIndex = parseInt(localStorage.getItem('historyIndex')) || 0; 

    // Retrocede el índice, volviendo al final del historial al llegar a 0
    currentIndex = (currentIndex - 1 + historyPattern.length) % historyPattern.length; 
    localStorage.setItem('historyIndex', currentIndex); 

    return historyPattern[currentIndex]; 
  } 
  return null; 
}

// HISTORIAL

//  Función para actualizar el select "historial" con los patrones
function updateHistorySelect() {
  const historialSelect = document.getElementById('historial');
  historialSelect.innerHTML = ''; //  Limpia las opciones existentes

  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern);

    //  Trunca el historial a 100 elementos si es más largo
    if (historyPattern.length > 100) {
      historyPattern = historyPattern.slice(0, 100);
    }

    //  Crea las opciones del select
    historyPattern.forEach(pattern => {
      const option = document.createElement('option');
      option.value = pattern;
      option.textContent = (pattern.length<10 ? " "+pattern.length:pattern.length) + ': ' + pattern;
      historialSelect.appendChild(option);
    });
  }
}

//  Listener para el select "historial"
const historialSelect = document.getElementById('historial');
historialSelect.addEventListener('change', () => {
  const selectedPattern = historialSelect.value; 
  if (selectedPattern) {
    beatPatternInput.value = selectedPattern; //  Inserta el patrón en el input
    beatPattern = selectedPattern;  //  Actualiza la variable beatPattern
    listPattern = transT2N(beatPattern);
    beatsPerMeasure = beatPattern.length; //  Recalcula beats por compás
    modal.style.display = "none";
    startIfIntervalId(); // Reinicia el metrónomo
  }
});

beatPatternInput.addEventListener('input', (event) => {
  beatPattern = beatPatternInput.value.toUpperCase().replace(/[^A-I0]/g, '');
  updatePatternLen(); // Actualiza la longitud del patrón (si estás usando esta función)
  startIfIntervalId(); // Reinicia el metrónomo
});
beatPatternInput.addEventListener('change', (event) => {
  beatPatternInput.value = beatPatternInput.value.toUpperCase().replace(/[^A-I0 ]/g, '');
});
// Actualiza el patrón de beats cuando se cambia el input de texto
beatPatternInput.addEventListener('keyup', (event) => { 
  const allowedChars = /^[a-z0-9A-Z]$/i;
  // Navega por el historial de patrones con las flechas arriba/abajo
  if (event.key === 'ArrowUp') {
    event.preventDefault(); 
    const previousString = getHistoryBack(); // Obtiene el patrón anterior
    if (previousString !== null) { 
      beatPatternInput.value = previousString; // Actualiza el input de texto
      beatPattern = previousString; // Actualiza el patrón actual
      updatePatternLen(); // Actualiza la longitud del patrón (si estás usando esta función)
      startIfIntervalId(); // Reinicia el metrónomo
    }
  } else if (event.key === 'ArrowDown') {
    event.preventDefault(); 
    const nextString = getHistoryNext(); // Obtiene el siguiente patrón
    if (nextString !== null) {
      beatPatternInput.value = nextString; // Actualiza el input de texto
      beatPattern = nextString; // Actualiza el patrón actual
      updatePatternLen(); // Actualiza la longitud del patrón (si estás usando esta función)
      startIfIntervalId(); // Reinicia el metrónomo
    }
  } else if (allowedChars.test(event.key)) {
    // Filtra los caracteres válidos
    let inputValue = beatPatternInput.value.toUpperCase();
    let filteredValue = "";
    let ss = beatPatternInput.selectionStart;
    let se = beatPatternInput.selectionEnd;
  
    for (let i = 0; i < inputValue.length; i++) {
      let char = inputValue[i];
      if (/[A-I0 ]/.test(char)) {
        filteredValue += char; // Mantiene el carácter válido
      } else {
        ss = ss-1;
        se = ss-0;
      }
      // Si no es válido, no se agrega al filteredValue (se reemplaza con '')
    }
    beatPatternInput.value = filteredValue; // Actualiza el valor del input
    beatPatternInput.setSelectionRange(ss, se);
  }
});

function updatePatternLen() {
  beatPattern = beatPatternInput.value.toUpperCase().replace(/[^A-I0]/g, '');
  listPattern = transT2N(beatPattern);
  beatsPerMeasure = beatPattern.length;
  patternLenDiv.innerHTML = beatsPerMeasure; //  Actualiza el div con la longitud
}

// SETTINGS

//  Modal de configuración:  obtener los elementos
const settingsIcon = document.querySelector('.settings-icon');
const modal = document.getElementById("settingsModal");
const spanClose = document.getElementsByClassName("close")[0];

//  Abrir el modal al hacer clic en el icono
settingsIcon.onclick = function() {
  modal.style.display = "block";
}

//  Cerrar el modal al hacer clic en el botón de cierre
spanClose.onclick = function() {
  modal.style.display = "none";
}

//  Cerrar el modal al hacer clic fuera del contenido
window.onclick = function(event) {
  if (event.target == modal) {
    modal.style.display = "none";
  }
}

// mute-icon
muteIcon.addEventListener('click', () => {
  toggleSelectAll();
});

// Vaciar historial listener
vaciarHistorial.addEventListener('click', () => {
  if (confirm("¿Confirma que desea vaciar su historial de patrones?")) {
    localStorage.clear();
    window.location.reload(); // Refresh for update
  }
});

//  DARK/LIGHT MODE SWITCH
//  Toggle dark mode on switch change
darkModeSwitch.addEventListener('change', () => {
  darkMode = darkModeSwitch.checked ? 1:0;
  saveSettings();
  //  DARK/LIGHT MODE SWITCH
  if (darkMode>0) {
    body.classList.add('dark-mode');
  } else {
    body.classList.remove('dark-mode');
  }
});


// EJECUCIÓN INICIAL

//  Llama a la función para actualizar el select al cargar la página
updateHistorySelect();
// Dibuja los colores de la rayas del circulo al iniciar
createHourMarks(beatsPerMeasure);
// Muestra la longitud del patrón al iniciar
updatePatternLen();
```

<!-- sw.js -->
```
const CACHE_NAME = 'metronomo-cache-v4'; // Increment version with each update
const urlsToCache = [
  '/metro/',
  'index.html',
  'metro.css',
  'beats.js',
  'metro.js',
  'metro.jpg',
  'icon-192x192.png',
  'icon-512x512.png',
  'favicon.png'
];

self.addEventListener('install', event => {
  // Make sure the new service worker takes over immediately
  self.skipWaiting(); 

  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', event => {
  // Clean up old caches on activation
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.filter(cacheName => {
          return cacheName !== CACHE_NAME; // Delete any caches that don't match
        }).map(cacheName => {
          return caches.delete(cacheName); 
        })
      );
    })
  );

  // Take control of existing clients
  return self.clients.claim(); 
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response; // Serve from cache if available
        }

        // Fetch from network if not in cache
        return fetch(event.request)
          .then(networkResponse => {
            // Cache the new response (for safe requests)
            if (networkResponse && networkResponse.status === 200 && 
                event.request.method === 'GET') { 

              const responseToCache = networkResponse.clone();
              caches.open(CACHE_NAME)
                .then(cache => {
                  cache.put(event.request, responseToCache);
                });
            }
            return networkResponse;
          })
          .catch(error => { 
            // Handle fetch errors (optional, but recommended)
            console.error('Fetch error:', error);
            // You could potentially return a fallback page here 
          });
      })
  );
});
```

<!-- metro2.css -->
```
@charset "UTF-8";

:root { /*  Variables globales  */
  --clock-size: 200px;
  --max-size: 320px;
  font-size: 16px;
}

/* Estilos generales */
body {
  background: #fff;
}

* {
  font-family: 'Roboto', Arial, sans-serif;
}

/* Contenedor principal del metrónomo */
.metronome {
  text-align: center;
  max-width: var(--max-size);
  margin: auto;
  position: relative;
}

h1 { /*  Encabezado  */
  margin-top: 0;
  margin-bottom: 0.5em;
}

p { /*  Párrafo explicativo  */
  text-align: left;
  font-size: 1.1em;
}

a { /*  Estilos para enlaces  */
  text-decoration: none;
  color: #400;
  font-weight: bold;
}

a:hover {
  text-decoration: underline;
}

/*  Recuadros generales  */
.recuadro {
  position: relative;
  display: inline-block;
  margin-bottom: 20px;
  padding: 10px;
  border: 1px dotted #888;
  border-radius: 10px;
  background: #FFFFFE;
}

/* Recuadro del reloj circular */
.recuadro.reloj {
  position: sticky;
  top: 2px;
  border-radius: 50%;
  padding: 1px;
  border: 2px solid #000;
  z-index: 2;
}

/* Contador de beat */
.recuadro.beat-counter {
  font-size: 3em;
  line-height: 80%;
  width: 1.5em;
}

/*  Controles  */
button {
  padding: 5px 15px;
  margin: 0 10px;
  font-size: 2em;
  font-family: serif;
  cursor: pointer;
}

select, input {
  font-size: 1.7em;
}

/* Sliders */
#bpmSlider, #volumen {
  width: var(--clock-size);
}

/*  Input del patrón de beats  */
#beatPattern {
  width: -moz-available;
  padding: 10px;
  font-size: 1.3em;
  font-family: 'Roboto Mono', 'Courier New', Courier, monospace;
}

#patternLen {
  position: absolute;
  top: 0;
  right: 0;
  color: chocolate;
  background-color: #fff;
  border-radius: 5px;
}

/*  Reloj circular  */
.clock {
  margin: auto;
  width: var(--clock-size);
  height: var(--clock-size);
  border-radius: 50%;
  border: 2px solid black;
  position: relative;
}

/* Marcas de hora */
.hour-mark {
  position: absolute;
  width: 3px;
  height: calc((var(--clock-size) / 2) + 1px);
  transform-origin: 50% 100%; /*  Rotar desde la parte inferior  */
  margin-top: -1px;
  margin-left: calc((var(--clock-size) / 2) - 1px);
  background-color: rgba(0, 0, 0, 0.2);
}

/*  Colores de las marcas para cada tipo de beat  */
.hour-mark.beat1 {
  background-color: rgba(255, 0, 0, 0.7);
}

.hour-mark.beat2 {
  background-color: rgba(0, 0, 255, 0.7);
}

.hour-mark.beat3 {
  background-color: rgba(0, 255, 0, 0.7);
}

.hour-mark.beat4 {
  background-color: rgba(0, 255, 255, 0.7);
}

.hour-mark.beat5 {
  background-color: rgba(255, 255, 0, 0.7);
}

.hour-mark.beat6 {
  background-color: rgba(255, 0, 255, 0.7);
}

.hour-mark.beat7 {
  background-color: rgba(255, 127, 127, 0.7);
}

.hour-mark.beat8 {
  background-color: rgba(127, 255, 127, 0.7);
}

.hour-mark.beat9 {
  background-color: rgba(127, 127, 255, 0.7);
}

/* Manecilla del reloj */
.hand {
  width: 5px;
  height: calc(var(--clock-size) / 2);
  background-color: black;
  position: absolute;
  top: 50%;
  left: 50%;
  transform-origin: 50% 100%; /*  Rotar desde la parte inferior  */
}

.hour-hand {
  height: calc(var(--clock-size) / 2);
  margin: 0;
  margin-left: -2px;
  margin-top: -50%;
}

/*  Cuadros de selección de números para silenciar  */
.numberContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  font-size: 1.4em;
}

.grid {
  display: grid;
  grid-template-columns: auto repeat(9, auto);
  gap: 0px;
}

.square {
  width: 22px;
  height: 22px;
  border: 2px solid #ccc;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 15px;
  cursor: pointer;
  margin: 2px;
}

.square:hover {
  border: 2px solid #444;
  border-radius: 50%;
}

.selected { /*  Cuadros seleccionados (silenciados)  */
  background-color: lightblue;
  text-decoration: line-through;
}

/*  SETTINGS  */

/* Icono de configuración */
.settings-icon {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 2em;
  cursor: pointer;
  color: #800;
}
.settings-icon:hover {
  color: chocolate;
}

#historial {
  font-size: 1.2em;
  width: 300px;
}

/*  Modal de configuración  */
.modal {
  display: none; /*  Oculto por defecto  */
  position: fixed; 
  z-index: 99; 
  left: 0;
  top: 0;
  width: 100%; 
  height: 100%; 
  overflow: auto; 
  background-color: rgba(0, 0, 0, 0.4);

.modal-content {
  background-color: #fefefe;
  margin: 10% auto; /*  Centrar horizontal y verticalmente  */
  padding: 10px 20px 20px 20px;
  border: 1px solid #222;
  width: 320px; 
  border-radius: 5px;
  box-shadow: 0 0 30px rgba(0,0,0,0.5);
}
}

/* Botón de cierre del modal */
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close:hover,
.close:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}

/*  Estilos para el grid de configuración  */
.settings-grid {
  display: grid;
  grid-template-columns: 1fr; /*  Una sola columna  */
  gap: 10px;
}

```

<!-- metro_old.css -->
```
:root {
  --clock-size: 200px;
  --max-size: 320px;
  font-size: 16px;
}
body {
  background: #fff;
}
* {
  font-family: 'Roboto', Arial, sans-serif;
}
.metronome {
  text-align: center;
  max-width: var(--max-size);
  margin: auto;
}

.recuadro {
  display:inline-block;
  margin-bottom: 20px;
  padding: 10px;
  border: 1px dotted #888;
  border-radius: 10px;
  background: #FFFFFE;
}
.reloj {
  position: sticky;
  top: 2px;
  border-radius: 50%;
  padding: 1px;
  border: 2px solid #000;
}

.beat-counter {
  font-size: 3em;
  line-height: 80%;
  width: 1.5em;
}

.clock {
  margin: auto;
  width: var(--clock-size);
  height: var(--clock-size);
  border-radius: 50%;
  border: 2px solid black;
  position: relative;
}

.hour-mark {
  position: absolute;
  width: 3px;
  height: calc((var(--clock-size) / 2) + 1px);
  transform-origin: 50% 100%; /* Rotate from the bottom */
  margin-top: -1px;
  margin-left: calc((var(--clock-size) / 2) - 1px);
  background-color: rgba(0,0,0,0.2);
}
.hour-mark.beat1 {
  background-color: rgba(255,0,0,0.7);
}
.hour-mark.beat2 {
  background-color:  rgba(0,0,255,0.7);
}
.hour-mark.beat3 {
  background-color:  rgba(0,255,0,0.7);
}
.hour-mark.beat4 {
  background-color:  rgba(0,255,255,0.7);
}
.hour-mark.beat5 {
  background-color:  rgba(255,255,0,0.7);
}
.hour-mark.beat6 {
  background-color:  rgba(255,0,255,0.7);
}
.hour-mark.beat7 {
  background-color:  rgba(255,127,127,0.7);
}
.hour-mark.beat8 {
  background-color:  rgba(127,255,127,0.7);
}
.hour-mark.beat9 {
  background-color:  rgba(127,127,255,0.7);
}

.hand {
  width: 5px;
  height: calc(var(--clock-size) / 2);
  background-color: black;
  position: absolute;
  top: 50%;
  left: 50%;
  transform-origin: 50% 100%; /* Rotate from the bottom */
}

.hour-hand {
  height: calc(var(--clock-size) / 2);
  margin:0;
  margin-left:-2px;
  margin-top:-50%;
}

button {
  padding: 5px 15px;
  margin: 0 10px;
  font-size: 2em;
  font-family: serif;
  cursor: pointer;
}
select,input {
  font-size: 1.7em;
}

#bpmSlider,#volumen {
  width: var(--clock-size);
}

#beatPattern {
  width: -moz-available;
  padding: 10px;
  font-size: 1.3em;
  font-family: 'Roboto Mono', 'Courier New', Courier, monospace;
}
h1 {
  margin-top: 0;
  margin-bottom: 0.5em;
}
p {
  text-align: left;
  font-size: 1.1em;
}
a {
  text-decoration: none;
  color: #400;
  font-weight: bold;
}
a:hover {
  text-decoration: underline;
}
.center {
  text-align: center;
}


.numberContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  font-size: 1.4em;
}

.grid {
  display: grid;
  grid-template-columns: auto repeat(9, auto);
  gap: 0px;
}

.square {
  width: 22px;
  height: 22px;
  border: 2px solid #ccc;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 15px;
  cursor: pointer;
  margin:2px;
}
.square:hover {
  border: 2px solid #444;
  border-radius: 50%;
}

.selected {
  background-color: lightblue;
  text-decoration: line-through;
}
```

<!-- metro_old.js -->
```
// metro.js
// Autor: Santiago Chávez Novaro
// Código Libre: Haz lo que quieras

// Set default UI values
let beatPattern = localStorage.getItem('beatPattern') || '1012'; // Default Patrón de golpes
let bpm = parseInt(localStorage.getItem('bpm')) || 120; // Default BPM/CPM
let isCPM = parseInt(localStorage.getItem('isCPM')) || 0; // Estamos en Compases Por Minuto? Default: 0
let volumen = parseFloat(localStorage.getItem('volumen')) || 1; // Volumen. Default 1=Max.
let selectedNumbers = JSON.parse(localStorage.getItem('selectedNumbers')) || []; // Volumen. Default 1=Max.

// Set UI elements
const startButton = document.getElementById('startButton');
const stopButton = document.getElementById('stopButton');
const beatPatternInput = document.getElementById('beatPattern');
const bpmcpm = document.getElementById('BPM-CPM');
const bpmInput = document.getElementById('bpmInput');
const bpmSlider = document.getElementById('bpmSlider');
const display = document.querySelector('.display');
const beatCounter = document.querySelector('.beat-counter');
const clock = document.querySelector('.clock');
const hourHand = document.querySelector('.hour-hand');
const volumeSlider = document.getElementById('volumen');
const grid = document.getElementById('numberGrid');

// Set global variables
let beatsPerMeasure = beatPattern.length;
let millisecondsPerBeat = 60000/bpm;
let isplaying = false;
let currentBeat = 0;
let intervalId;

// Update default values to UI
bpmInput.value = bpm;
bpmSlider.value = bpm;
beatPatternInput.value = beatPattern;
bpmcpm.value = isCPM;
volumeSlider.value = volumen;

// Functions
function saveSettings() {
  localStorage.setItem('beatPattern', beatPattern);
  localStorage.setItem('bpm', bpm);
  localStorage.setItem('isCPM', isCPM);
  localStorage.setItem('volumen',volumen);
  localStorage.setItem('selectedNumbers', JSON.stringify(selectedNumbers));
}

function createHourMarks(beatsPerMeasure) {
  // Clear existing hour marks
  const elementsToDelete = document.querySelectorAll('.hour-mark');
  elementsToDelete.forEach(element => element.remove());

  for (let i = 0; i < beatsPerMeasure; i++) {
    const hourMark = document.createElement('div');
    hourMark.classList.add('hour-mark');

    if(beatPattern[i]!='0') {
      hourMark.classList.add('beat'+beatPattern[i]);
    }
    const angle = (i / beatsPerMeasure) * 360;
    hourMark.style.transform = `rotate(${angle}deg)`;
    clock.appendChild(hourMark);
  }
}


function updateClock(beatsPerMeasure) {
  const hourAngle = (currentBeat / beatsPerMeasure) * 360; // Calculate angle based on BPM
  beatCounter.innerText = currentBeat+1;
  hourHand.style.transform = `rotate(${hourAngle}deg)`;
}

// Load sound files using Howler.js
let sound = [];
for(var i = 0 ; i<base64Beat.length;i++){
  sound.push(new Howl({
    src: [base64Beat[i]]
    //src: ['https://s3-us-west-2.amazonaws.com/s.cdpn.io/3/success.mp3']
  }));
}

function playBeat(beat) {
  beat = parseInt(beat);
  if(beat>0 && !selectedNumbers.includes(beat)) {
    sound[beat-1].play();
  }
}

function startMetronome() {
  saveSettings();
  beatPattern = beatPatternInput.value.toUpperCase().replace(/[^0-9]/g, '');
  updateHistoryPattern(beatPattern);
  beatsPerMeasure = beatPattern.length;
  millisecondsPerBeat = (60000 / bpm)
  if(isCPM>0) {
    millisecondsPerBeat = millisecondsPerBeat / beatsPerMeasure;
  }
  
  createHourMarks(beatsPerMeasure); // Create hour marks based on beats per bar

  isplaying = true;

  intervalId = setInterval(() => {
    playBeat(beatPattern[currentBeat]);
    
    currentHour = currentBeat; // Update hour hand position
    updateClock(beatsPerMeasure);
    
    currentBeat = (currentBeat + 1) % beatsPerMeasure;
  }, millisecondsPerBeat);

  startButton.disabled = true;
  stopButton.disabled = false;
}

function stopMetronome() {
  clearInterval(intervalId);
  isplaying = false;
  startButton.disabled = false;
  stopButton.disabled = true;
  currentBeat = 0;
}

function startIfIntervalId() {
  if (intervalId) {
    clearInterval(intervalId);
    if(isplaying) {
        startMetronome();
    }
  }  
}

// Listeners
bpmInput.addEventListener('input', () => {
  bpm = parseInt(bpmInput.value);
  bpmSlider.value = bpm;
  startIfIntervalId();
});

bpmSlider.addEventListener('input', () => {
  bpm = parseInt(bpmSlider.value);
  bpmInput.value = bpm;
  startIfIntervalId();
});

bpmcpm.addEventListener('input', () => {
  isCPM = parseInt(bpmcpm.value);
  bpmcpm.value = isCPM;
  startIfIntervalId();
});

beatPatternInput.addEventListener('change', () => {
  beatPattern = beatPatternInput.value.toUpperCase().replace(/[^0-9]/g, '');
  beatsPerMeasure = beatPattern.length;
  startIfIntervalId();
});

volumeSlider.addEventListener('input', () => {
  volumen = parseFloat(volumeSlider.value);
  sound.forEach(s => s.volume(volumen));
  saveSettings();
});

startButton.addEventListener('click', startMetronome);
stopButton.addEventListener('click', stopMetronome);


// Crea lo Cuadros de Números de 1-9
for (let i = 1; i <= 9; i++) {
  const square = document.createElement('div');
  square.classList.add('square');
  square.textContent = i;
  square.addEventListener('click', toggleSelect);
  grid.appendChild(square);
  if (selectedNumbers.includes(i)) {
    square.classList.add('selected');
  }
}
function toggleSelect(event) {
  const square = event.target;
  const number = parseInt(square.textContent);
  if (square.classList.contains('selected')) {
    square.classList.remove('selected');
    selectedNumbers = selectedNumbers.filter(n => n !== number);
  } else {
    square.classList.add('selected');
    selectedNumbers.push(number);
  }
  saveSettings();
}

function updateHistoryPattern(pattern) {
  // 1. Get existing history from localStorage 
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern); // Parse if it exists
  } else {
    historyPattern = []; // Create an empty array if not
  }

  // 2.  Check for duplicates and update the array
  const existingIndex = historyPattern.indexOf(pattern);
  if (existingIndex !== -1) {
    historyPattern.splice(existingIndex, 1); // Remove if duplicate exists
  }
  historyPattern.unshift(pattern); // Add to the beginning (newest first)

  // 3.  Store the updated history back in localStorage
  localStorage.setItem('historyPattern', JSON.stringify(historyPattern));
}

// Function to move forward in history (get next string)
function getHistoryNext() {
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern); 
    let currentIndex = parseInt(localStorage.getItem('historyIndex')) || 0; 

    // Move index forward, wrapping to 0 at the end
    currentIndex = (currentIndex + 1) % historyPattern.length;
    localStorage.setItem('historyIndex', currentIndex);

    return historyPattern[currentIndex]; 
  } 
  return null; // Or return a default value if history is empty
}

// Function to move backward in history (get previous string)
function getHistoryBack() {
  let historyPattern = localStorage.getItem('historyPattern');
  if (historyPattern) {
    historyPattern = JSON.parse(historyPattern);
    let currentIndex = parseInt(localStorage.getItem('historyIndex')) || 0; 

    // Move index backward, wrapping to the end of the array
    currentIndex = (currentIndex - 1 + historyPattern.length) % historyPattern.length; 
    localStorage.setItem('historyIndex', currentIndex); 

    return historyPattern[currentIndex]; 
  } 
  return null; // Or return a default value if history is empty
}

beatPatternInput.addEventListener('keyup', (event) => { 
  if (event.key === 'ArrowUp') {
    event.preventDefault(); // Prevent cursor from moving to start
    const previousString = getHistoryBack();
    if (previousString !== null) { 
      beatPatternInput.value = previousString; 
      beatPattern = previousString; 
      beatsPerMeasure = beatPattern.length;
      startIfIntervalId();
    }
  } else if (event.key === 'ArrowDown') {
    event.preventDefault(); // Prevent cursor from moving to end
    const nextString = getHistoryNext();
    if (nextString !== null) {
      beatPatternInput.value = nextString; 
      beatPattern = nextString; 
      beatsPerMeasure = beatPattern.length;
      startIfIntervalId();
    }
  }
});
```

